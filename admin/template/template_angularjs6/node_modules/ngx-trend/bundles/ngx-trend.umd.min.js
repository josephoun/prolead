!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("@angular/animations"),require("@angular/core"),require("@angular/common")):"function"==typeof define&&define.amd?define(["exports","@angular/animations","@angular/core","@angular/common"],n):n(t["ngx-trend"]={},t.ng.animations,t.ng.core,t.ng.common)}(this,function(t,n,e,a){"use strict";function i(t,n){var e="function"==typeof Symbol&&t[Symbol.iterator];if(!e)return t;var a,i,r=e.call(t),o=[];try{for(;(void 0===n||n-- >0)&&!(a=r.next()).done;)o.push(a.value)}catch(s){i={error:s}}finally{try{a&&!a.done&&(e=r["return"])&&e.call(r)}finally{if(i)throw i.error}}return o}function r(){for(var t=[],n=0;n<arguments.length;n++)t=t.concat(i(arguments[n]));return t}function o(t,n,e,a,i){return void 0===a&&(a=0),void 0===i&&(i=1),n===e?a:a+(t-n)*(i-a)/(e-n)}function s(t,n,e){var a=Math.sqrt((t.x-n.x)*(t.x-n.x)+(t.y-n.y)*(t.y-n.y)),i=(t.x-n.x)/a,r=(t.y-n.y)/a;return{x:n.x+i*e,y:n.y+r*e}}var h=function(t,n){return Math.sqrt(Math.pow(n.x-t.x,2)+Math.pow(n.y-t.y,2))},u=function(t,n,e){return(t.y-n.y)*(t.x-e.x)==(t.y-e.y)*(t.x-n.x)};var d=function(){return Math.round(Math.random()*Math.pow(10,16))};var p=function(){function t(){this.autoDraw=!1,this.autoDrawDuration=2e3,this.autoDrawEasing="ease",this.padding=8,this.radius=10,this.stroke="black",this.strokeLinecap="",this.strokeWidth=1,this.gradient=[],this.svgWidth="100%",this.svgHeight="25%",this.animationState="",this.id=d(),this.gradientId="ngx-trend-vertical-gradient-"+this.id}return t.prototype.ngOnChanges=function(){var t=this;if(this.data&&!(this.data.length<2)){var n=this.data.map(function(t){return"number"==typeof t?t:t.value}),e=this.width||300,a=this.height||75;this.svgWidth=this.width||"100%",this.svgHeight=this.height||"25%",this.viewBox="0 0 "+e+" "+a;var d=location.href.split(location.hash||"#")[0];this.pathStroke=this.gradient&&this.gradient.length?"url('"+d+"#"+this.gradientId+"')":undefined,this.gradientTrimmed=this.gradient.slice().reverse().map(function(n,e){return{idx:e,stopColor:n,offset:o(e,0,t.gradient.length-1||1)}});var p,g,l,y,c,f,m,x,v,w,k,D,I,M=(p=n,g=this.padding,l=e-this.padding,y=a-this.padding,c=this.padding,f={min:0,max:p.length-1},m={min:Math.min.apply(Math,r(p)),max:Math.max.apply(Math,r(p))},x=p.map(function(t,n){return{x:o(n,f.min,f.max,g,l),y:o(t,m.min,m.max,y,c)}}),m.min===m.max&&(x[0].y+=1e-4),x);this.autoDraw&&"active"!==this.animationState&&(this.animationState="inactive",setTimeout(function(){t.lineLength=t.pathEl.nativeElement.getTotalLength(),t.animationState="active"})),this.d=this.smooth?(v=M,w=this.radius,k=i(v),D=k[0],(I=k.slice(1)).reduce(function(t,n,e){var a=I[e+1],i=I[e-1]||D,r=a&&u(i,n,a);if(!a||r)return t+"\nL "+n.x+","+n.y;var o=h(i,n),d=h(a,n),p=Math.min(o,d),g=p/2<w?p/2:w,l=s(i,n,g),y=s(a,n,g);return[t,"L "+l.x+","+l.y,"S "+n.x+","+n.y+" "+y.x+","+y.y].join("\n")},"M "+D.x+","+D.y)):M.reduce(function(t,n,e){return t+(0===e?"M":"L")+" "+n.x+","+n.y+"\n"},"")}},t}();p.decorators=[{type:e.Component,args:[{selector:"ngx-trend",template:'\n  <svg *ngIf="data && data.length >= 2"\n    [attr.width]="svgWidth"\n    [attr.height]="svgHeight"\n    [attr.stroke]="stroke"\n    [attr.stroke-width]="strokeWidth"\n    [attr.stroke-linecap]="strokeLinecap"\n    [attr.viewBox]="viewBox"\n  >\n    <defs *ngIf="gradient && gradient.length">\n      <linearGradient [attr.id]="gradientId"\n        x1="0%" y1="0%" x2="0%" y2="100%"\n      >\n        <stop\n          *ngFor="let g of gradientTrimmed;"\n          [attr.key]="g.idx"\n          [attr.offset]="g.offset"\n          [attr.stop-color]="g.stopColor"\n        />\n      </linearGradient>\n    </defs>\n    <path fill="none" #pathEl\n      [attr.stroke]="pathStroke" [attr.d]="d"\n      [@pathAnimaiton]="{\n        value: animationState,\n        params: {\n          autoDrawDuration: autoDrawDuration,\n          autoDrawEasing: autoDrawEasing,\n          lineLength: lineLength\n        }\n      }" />\n  </svg>\n  ',animations:[n.trigger("pathAnimaiton",[n.state("inactive",n.style({display:"none"})),n.transition("* => active",[n.animate("{{ autoDrawDuration }}ms {{ autoDrawEasing }}",n.keyframes([n.style({"stroke-dasharray":"{{ lineLength }}px","stroke-dashoffset":"{{ lineLength }}px"}),n.style({"stroke-dasharray":"{{ lineLength }}px","stroke-dashoffset":0})])),n.style({"stroke-dashoffset":"","stroke-dasharray":""})])])]}]}],p.ctorParameters=function(){return[]},p.propDecorators={data:[{type:e.Input}],smooth:[{type:e.Input}],autoDraw:[{type:e.Input}],autoDrawDuration:[{type:e.Input}],autoDrawEasing:[{type:e.Input}],width:[{type:e.Input}],height:[{type:e.Input}],padding:[{type:e.Input}],radius:[{type:e.Input}],stroke:[{type:e.Input}],strokeLinecap:[{type:e.Input}],strokeWidth:[{type:e.Input}],gradient:[{type:e.Input}],pathEl:[{type:e.ViewChild,args:["pathEl"]}]};var g=function(){return function(){}}();g.decorators=[{type:e.NgModule,args:[{imports:[a.CommonModule],exports:[p],declarations:[p]}]}],g.ctorParameters=function(){return[]},t.TrendComponent=p,t.TrendModule=g,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=ngx-trend.umd.min.js.map
